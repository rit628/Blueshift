#!/usr/bin/env python3
import argparse
import os
import re
import sys
import atexit
import subprocess
import socket
import time
import multiprocessing as mp

PROJECT_NAME = os.environ.get("PROJECT_NAME")
PROJECT_PREFIX = os.environ.get("PROJECT_PREFIX")
NETWORK_NAME = os.environ.get("NETWORK_NAME")
DEFAULT_NUM_CLIENTS = os.environ.get("NUM_CLIENTS")
BUILD_MOUNT_DIR = os.environ.get("BUILD_MOUNT_DIR")
BUILD_OUTPUT_DIRECTORY = os.environ.get("BUILD_OUTPUT_DIRECTORY")
RUNTIME_OUTPUT_DIRECTORY = os.environ.get("RUNTIME_OUTPUT_DIRECTORY")
REMOTE_OUTPUT_DIRECTORY = os.environ.get("REMOTE_OUTPUT_DIRECTORY")
NUM_CORES = mp.cpu_count()

def supressPythonErrors():
    pass

def clean_shutdown(base_cmd):
    subprocess.run(base_cmd + ["down"])

def check_successful_reset_or_force():
    network_id = subprocess.check_output(f"docker network ls | grep {NETWORK_NAME} | awk '{{ print $1 }}'",
                                         text=True, shell=True)

    container_ids = subprocess.check_output(f"docker container ls | grep {PROJECT_PREFIX} | awk '{{ print $1 }}'",
                                            text=True, shell=True).strip()

    image_ids = subprocess.check_output(f"docker image ls | grep {PROJECT_PREFIX} | awk '{{ print $3 }}'",
                                     text=True, shell=True).strip()
    
    volumes = subprocess.check_output(f"docker volume ls | grep {PROJECT_NAME} | awk '{{ print $2 }}'",
                                     text=True, shell=True).strip()
        
    if any((network_id, container_ids, image_ids, volumes)):
        subprocess.run(["docker", "network", "rm", network_id])
        subprocess.run(["docker", "container", "stop"] + container_ids.split('\n'))
        subprocess.run(["docker", "container", "rm", "-f"] + container_ids.split('\n'))
        subprocess.run(["docker", "image", "prune", "-f"])
        subprocess.run(["docker", "image", "rm", "-f"] + image_ids.split('\n'))
        subprocess.run(["docker", "volume", "rm", "-f"] + volumes.split('\n'))

def wait_for_lldb_server(port):
    shell = subprocess.Popen(os.environ.get("SHELL"), shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    pattern = re.compile(f"{port}/tcp")
    while(True):
        out, _ = shell.communicate("docker container ls")
        if pattern.search(out):
            return
        time.sleep(.25)

def get_free_port():
    sock = socket.socket()
    sock.bind(('', 0))
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    return sock.getsockname()[1]

def run(args):
    sys.stderr = supressPythonErrors()
    if args.local:
        executable = os.path.join("." ,BUILD_OUTPUT_DIRECTORY, RUNTIME_OUTPUT_DIRECTORY, args.binary)
        subprocess.run([executable, *args.binary_args], check=True)
    else:
        subprocess.run(["docker", "compose", "run", "--rm", "builder",  "run", "-l", args.binary, *args.binary_args], check=True)

def debug(args):
    executable = os.path.join("." ,BUILD_OUTPUT_DIRECTORY, RUNTIME_OUTPUT_DIRECTORY, args.binary)
    allow_visual = not args.terminal and args.debugger == "lldb"
    debug_name = str(args.binary).capitalize()
    # Add controller name to debug name for readability
    debug_name += "-" + str(args.binary_args[0]) if args.binary == "client" and len(args.binary_args) > 0 else ""
    CODELLDB_ADDRESS = ("127.0.0.1", 7349)

    if args.server:
        if args.debugger == "lldb":
            subprocess.run(["lldb-server", "gdbserver", f"*:{args.server}", "--", executable, *args.binary_args])
        else:
            subprocess.run(["gdbserver", f"*:{args.server}", executable, *args.binary_args])
    elif args.local:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            if allow_visual and s.connect_ex(CODELLDB_ADDRESS) == 0: # debug locally with codelldb
                s.sendall(f"""
                {{
                    name: '{debug_name}',
                    token: 'blueshift',
                    terminal: 'console',
                    program: {executable},
                    args: {args.binary_args}
                }}
                """.encode())
            else: # debug locally in terminal
                args_command = "--" if args.debugger == "lldb" else "--args"
                subprocess.run([args.debugger, args_command, executable, *args.binary_args])
    else:
        DEBUG_SERVER_PORT = get_free_port()
        remote_binary = os.path.join(REMOTE_OUTPUT_DIRECTORY, RUNTIME_OUTPUT_DIRECTORY, args.binary)
        cwd = os.getcwd()
        # Initialize debug server
        subprocess.run(["docker", "container", "stop", "-t", "1", f"{debug_name}"])
        subprocess.run(["docker", "compose", "run", "-d", "-p", f"{DEBUG_SERVER_PORT}:{DEBUG_SERVER_PORT}", "--name", debug_name, "--rm",
                        "builder", "debug", "--server", f"{DEBUG_SERVER_PORT}", "--debugger", args.debugger, args.binary, *args.binary_args])
        wait_for_lldb_server(DEBUG_SERVER_PORT)

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            if allow_visual and s.connect_ex(CODELLDB_ADDRESS) == 0: # debug remotely with 
                s.sendall(f"""
                {{
                    name: '{debug_name}',
                    token: 'blueshift',
                    terminal: 'console',
                    request: 'launch',
                    sourceMap: {{ {BUILD_MOUNT_DIR} : {cwd} }},
                    targetCreateCommands: ["target create {remote_binary}"],
                    processCreateCommands: ["gdb-remote localhost:{DEBUG_SERVER_PORT}"]
                }}
                """.encode())
            elif args.debugger == "lldb":
                time.sleep(.25) # externally extend gdb-remote connection timeout
                subprocess.run(["lldb", "-o", f"settings set target.source-map {BUILD_MOUNT_DIR} {cwd}",
                                "-o", f"gdb-remote localhost:{DEBUG_SERVER_PORT}", "--", remote_binary, *args.binary_args])
            else:
                subprocess.run(["gdb", "-ex", f"target remote localhost:{DEBUG_SERVER_PORT}",
                                "-ex", f"set substitute-path {BUILD_MOUNT_DIR} {cwd}",
                                "--args", remote_binary, *args.binary_args])


def deploy(args):
    base_cmd = ["docker", "compose"]
    atexit.register(clean_shutdown, base_cmd)
    
    command = [*base_cmd, "up"]
    os.environ["DEPLOY_SRC"] = f"samples/src/{args.filename}"
    if args.num_clients:
        os.environ["NUM_CLIENTS"] = args.num_clients
    if args.build:
        command.append("--build")

    subprocess.run(command)

def build(args):
    sys.stderr = supressPythonErrors()
    build_args = [f"--build-type", args.build_type,
                  "--compiler", args.compiler,
                  "--parallel", str(args.parallel)]
    if args.image_build:
        subprocess.run(["docker", "compose", "build"])
    if args.clean:
        build_args.append("--clean")
        subprocess.run(["rm", "-rf", "build"])
    
    if not args.no_local_generation:
        cpp_compiler = f"-DCMAKE_CXX_COMPILER={args.compiler}"
        c_compiler = "-DCMAKE_C_COMPILER="
        linker = "-DCMAKE_LINKER="
        build_type = f"-DCMAKE_BUILD_TYPE={args.build_type}"
        if args.compiler == 'clang++':
            c_compiler += "clang"
            linker += "lld"
        else:
            c_compiler += "gcc"
            linker += "ld"

        cmake_args = [c_compiler, cpp_compiler, linker, build_type]
        subprocess.run(["cmake", *cmake_args, "-S", ".", "-B", "build"], check=True)

    if args.local:
        # 1 <= j <= n-1 (keep 1 core free for background tasks)
        core_count = str(max(1, min(args.parallel, NUM_CORES - 1)))
        subprocess.run(["cmake", "--build", ".", "-j", core_count, "-t", *args.make], cwd=f"./{BUILD_OUTPUT_DIRECTORY}", check=True)
    else:
        # build binaries on remote container
        subprocess.run(["docker", "compose", "run", "--rm", "builder",  "build", "-l", *build_args, *args.make], check=True)
        # synchronize host and remote binaries for debug symbol access
        subprocess.run(["docker", "compose", "run", "--rm", "synchronizer"], check=True)

def test(args):
    sys.stderr = supressPythonErrors()
    os.environ["GTEST_COLOR"] = "1"
    ctest_args = [args.verbose, "-R", args.tests_regex]
    ctest_args = list(filter(None, ctest_args))
    if args.local:
        fail_output = ["--output-on-failure"] if not args.no_output_on_failure else []
        subprocess.run(["ctest", *fail_output, *ctest_args], cwd=f"./{BUILD_OUTPUT_DIRECTORY}", check=True)
    else:
        subprocess.run(["docker", "compose", "run", "--rm", "builder", "test", "-l", *ctest_args], check=True)

def reset(args):
    subprocess.run(["docker", "compose", "down", "--rmi", "all", "-v", "--remove-orphans"])
    subprocess.run(["rm", "-rf", "build"])
    
    check_successful_reset_or_force()

    if args.rm_build_cache:
        subprocess.run(["docker", "buildx", "prune", "-f"])

parser = argparse.ArgumentParser(description=f"{PROJECT_NAME} development environment build script", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
subparsers = parser.add_subparsers(title="commands")

run_parser = subparsers.add_parser("run", help=f"run selected {PROJECT_NAME} binaries")
run_parser.add_argument("binary",
                        help="binary to execute")
run_parser.add_argument("binary_args",
                        help="program arguments",
                        nargs="*",
                        default=None)
run_parser.add_argument("-l", "--local",
                        help="run selected binary on local host instead of in containerized environment",
                        action="store_true")
run_parser.set_defaults(fn=run)

debug_parser = subparsers.add_parser("debug", help=f"debug selected {PROJECT_NAME} binaries")
debug_parser.add_argument("binary",
                        help="binary to debug")
debug_parser.add_argument("binary_args",
                        help="program arguments",
                        nargs="*",
                        default=None)
debug_parser.add_argument("-l", "--local",
                        help="debug selected binary on local host instead of in containerized environment",
                        action="store_true")
debug_parser.add_argument("-s", "--server",
                        help="create a gdb-server instance to attach to remotely at the specified port",
                        default=None)
debug_parser.add_argument("-t", "--terminal",
                        help="force debugging through terminal alone",
                        action="store_true")
debug_parser.add_argument("-d", "--debugger",
                        help="choose a specific debugger (note that the VSCode visual debugger is only supported with lldb)",
                        choices=["lldb", "gdb"],
                        default="lldb")
debug_parser.set_defaults(fn=debug)

deploy_parser = subparsers.add_parser("deploy", help=f"run {PROJECT_NAME} deployment environment (send SIGINT [ctrl+c] to stop gracefully)")
deploy_parser.add_argument("filename",
                          help="source file to execute",
                          nargs="?",
                          default="main.blu")
deploy_parser.add_argument("-n", "--num-clients",
                           help="number of clients to create (only used in deployment simulation)",
                           default=DEFAULT_NUM_CLIENTS)
deploy_parser.add_argument("-b", "--build",
                           help="rebuild container images before running",
                           action="store_true")
deploy_parser.set_defaults(fn=deploy)

build_parser = subparsers.add_parser("build", help=f"build {PROJECT_NAME} binaries or deployment images")
build_parser.add_argument("make",
                          help="makefile arguments",
                          nargs="*",
                          default=["all"])
build_parser.add_argument("-i", "--image-build",
                          help="build container images",
                          action="store_true")
build_parser.add_argument("-c", "--compiler",
                          help="set compiler used for building",
                          choices=["clang++", "g++"],
                          default="clang++")
build_parser.add_argument("-j", "--parallel",
                          help="set number of logical cores to use for compilation",
                          type=int,
                          default=NUM_CORES)
build_parser.add_argument("-t", "--build-type",
                          help="set cmake build type",
                          choices=["Debug", "Release"],
                          default="Debug")
build_parser.add_argument("-l", "--local",
                          help="build for local host only; container builds are not updated",
                          action="store_true")
build_parser.add_argument("--clean",
                          help="clean build directory before building",
                          action="store_true")
build_parser.add_argument("--no-local-generation",
                          help="disable generation of build artifacts in local environment",
                          action="store_true")
build_parser.set_defaults(fn=build)

test_parser = subparsers.add_parser("test", help=f"test {PROJECT_NAME} binary and library builds")
test_parser.add_argument("-v", "--verbose",
                         help="show verbose output",
                         action="store_const",
                         const="--verbose")
test_parser.add_argument("--no-output-on-failure",
                         help="show condensed output regardless of failed tests",
                         action="store_true")
test_parser.add_argument("-l", "--local",
                         help="test on local host only; container builds are not tested",
                         action="store_true")
test_parser.add_argument("-R", "--tests-regex",
                         help="run subset of tests matching regular expression",
                         default=".*")
test_parser.set_defaults(fn=test)

reset_parser = subparsers.add_parser("reset", help="resets images and volumes")
reset_parser.add_argument("--rm-build-cache",
                          help="clears dangling docker build cache",
                          action="store_true")
reset_parser.set_defaults(fn=reset)

args = parser.parse_args(args=None if len(sys.argv) > 1 else ["--help"])
args.fn(args)